# -*- coding: utf-8 -*-
# @Time    : 2020/4/10 8:17 上午
# @Author  : siJi
# @File    : 200_岛屿数量.py
# @Desc    :

"""
给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。

示例 1:
输入:
11110
11010
11000
00000
输出: 1

示例 2:
输入:
11000
11000
00100
00011
输出: 3
"""


class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        pass
        '''
        方法一 DFS 递归
        
        线性扫描整个二维网格，如果一个结点包含 1，则以其为根结点启动深度优先搜索。
        在深度优先搜索过程中，每个访问过的结点被标记为 0。计数启动深度优先搜索的根结点的数量，即为岛屿的数量。
        
        时间复杂度 O(M*N)
        空间复杂度 O(M*N)
        '''

        # def dfs(grid, i, j):
        #     # 上下左右
        #     grid[i][j] = '0'
        #     if i - 1 >= 0 and grid[i - 1][j] == '1': dfs(grid, i - 1, j)
        #     if i + 1 < len(grid) and grid[i + 1][j] == '1': dfs(grid, i + 1, j)
        #     if j - 1 >= 0 and grid[i][j - 1] == '1': dfs(grid, i, j - 1)
        #     if j + 1 < len(grid[0]) and grid[i][j + 1] == "1": dfs(grid, i, j + 1)
        #
        #
        # res = 0
        # for i in range(len(grid)):
        #     for j in range(len(grid[0])):
        #         if grid[i][j] == "1":
        #             res += 1
        #             dfs(grid, i, j)
        # return res

        '''
        方法一 BFS 队列
        线性扫描整个二维网格，如果一个结点包含 1，则以其为根结点启动广度优先搜索。
        将其放入队列中，并将值设为 0 以标记访问过该结点。迭代地搜索队列中的每个结点，直到队列为空。

        时间复杂度 O(M*N)
        空间复杂度 O(M*N)
        '''
        # from collections import deque
        # if not grid: return 0
        # row = len(grid)
        # col = len(grid[0])
        # cnt = 0
        #
        # def bfs(i, j):
        #     queue = deque()
        #     queue.appendleft((i, j))
        #     grid[i][j] = "0"
        #     while queue:
        #         i, j = queue.pop()
        #         for x, y in [[-1, 0], [1, 0], [0, -1], [0, 1]]:
        #             tmp_i = i + x
        #             tmp_j = j + y
        #             if 0 <= tmp_i < row and 0 <= tmp_j < col and grid[tmp_i][tmp_j] == "1":
        #                 grid[tmp_i][tmp_j] = "0"
        #                 queue.appendleft((tmp_i, tmp_j))
        #
        # for i in range(row):
        #     for j in range(col):
        #         if grid[i][j] == "1":
        #             bfs(i, j)
        #             cnt += 1
        # return cnt

        '''
        方法三 并查集
        '''
        f = {}

        def find(x):
            f.setdefault(x, x)
            if f[x] != x:
                f[x] = find(f[x])
            return f[x]

        def union(x, y):
            f[find(x)] = find(y)

        if not grid: return 0
        row = len(grid)
        col = len(grid[0])

        for i in range(row):
            for j in range(col):
                if grid[i][j] == "1":
                    for x, y in [[-1, 0], [0, -1]]:
                        tmp_i = i + x
                        tmp_j = j + y
                        if 0 <= tmp_i < row and 0 <= tmp_j < col and grid[tmp_i][tmp_j] == "1":
                            union(tmp_i * row + tmp_j, i * row + j)
        # print(f)
        res = set()
        for i in range(row):
            for j in range(col):
                if grid[i][j] == "1":
                    res.add(find((i * row + j)))
        return len(res)


if __name__ == "__main__":
    # grid = [["1", "1", "0", "0", "0"], ["1", "1", "0", "0", "0"], ["0", "0", "1", "0", "0"], ["0", "0", "0", "1", "1"]]
    grid = [["1", "0", "0", "1", "1", "1", "0", "1", "1", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["1", "0", "0", "1", "1", "0", "0", "1", "0", "0", "0", "1", "0", "1", "0", "1", "0", "0", "1", "0"],
            ["0", "0", "0", "1", "1", "1", "1", "0", "1", "0", "1", "1", "0", "0", "0", "0", "1", "0", "1", "0"],
            ["0", "0", "0", "1", "1", "0", "0", "1", "0", "0", "0", "1", "1", "1", "0", "0", "1", "0", "0", "1"],
            ["0", "0", "0", "0", "0", "0", "0", "1", "1", "1", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["1", "0", "0", "0", "0", "1", "0", "1", "0", "1", "1", "0", "0", "0", "0", "0", "0", "1", "0", "1"],
            ["0", "0", "0", "1", "0", "0", "0", "1", "0", "1", "0", "1", "0", "1", "0", "1", "0", "1", "0", "1"],
            ["0", "0", "0", "1", "0", "1", "0", "0", "1", "1", "0", "1", "0", "1", "1", "0", "1", "1", "1", "0"],
            ["0", "0", "0", "0", "1", "0", "0", "1", "1", "0", "0", "0", "0", "1", "0", "0", "0", "1", "0", "1"],
            ["0", "0", "1", "0", "0", "1", "0", "0", "0", "0", "0", "1", "0", "0", "1", "0", "0", "0", "1", "0"],
            ["1", "0", "0", "1", "0", "0", "0", "0", "0", "0", "0", "1", "0", "0", "1", "0", "1", "0", "1", "0"],
            ["0", "1", "0", "0", "0", "1", "0", "1", "0", "1", "1", "0", "1", "1", "1", "0", "1", "1", "0", "0"],
            ["1", "1", "0", "1", "0", "0", "0", "0", "1", "0", "0", "0", "0", "0", "0", "1", "0", "0", "0", "1"],
            ["0", "1", "0", "0", "1", "1", "1", "0", "0", "0", "1", "1", "1", "1", "1", "0", "1", "0", "0", "0"],
            ["0", "0", "1", "1", "1", "0", "0", "0", "1", "1", "0", "0", "0", "1", "0", "1", "0", "0", "0", "0"],
            ["1", "0", "0", "1", "0", "1", "0", "0", "0", "0", "1", "0", "0", "0", "1", "0", "1", "0", "1", "1"],
            ["1", "0", "1", "0", "0", "0", "0", "0", "0", "1", "0", "0", "0", "1", "0", "1", "0", "0", "0", "0"],
            ["0", "1", "1", "0", "0", "0", "1", "1", "1", "0", "1", "0", "1", "0", "1", "1", "1", "1", "0", "0"],
            ["0", "1", "0", "0", "0", "0", "1", "1", "0", "0", "1", "0", "1", "0", "0", "1", "0", "0", "1", "1"],
            ["0", "0", "0", "0", "0", "0", "1", "1", "1", "1", "0", "1", "0", "0", "0", "1", "1", "0", "0", "0"]]
    print(Solution().numIslands(grid))
