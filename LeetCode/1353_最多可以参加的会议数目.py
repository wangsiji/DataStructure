# -*- coding: utf-8 -*-
# @Time    : 2020/3/29 7:42 下午
# @Author  : siJi
# @File    : 1353_最多可以参加的会议数目.py
# @Desc    :


"""
给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。

你可以在满足 startDayi <= d <= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。

请你返回你可以参加的 最大 会议数目。

示例 2：
输入：events = [[1,2],[2,3],[3,4]]
输出：3
解释：你可以参加所有的三个会议。
安排会议的一种方案如上图。
第 1 天参加第一个会议。
第 2 天参加第二个会议。
第 3 天参加第三个会议。

示例 2：
输入：events= [[1,2],[2,3],[3,4],[1,2]] 输出：4

示例 3：
输入：events = [[1,4],[4,4],[2,2],[3,4],[1,1]] 输出：4

示例 4：
输入：events = [[1,100000]] 输出：1

示例 5：
输入：events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]] 输出：7
"""

'''
优先队列也是一种队列，与队列不同的是，优先队列不再遵循先入先出的原则，而是分成了两种情况：

最大优先队列，无论入队顺序，当前最大的元素优先出队。 最小优先队列，无论入队顺序，当前最小的元素优先出队。

事实上，优先队列的本质上是一个堆，它是一棵完全二叉树，分为小顶堆和大顶堆：
    小顶堆是每一个根节点小于左右子节点的完全二叉树，堆顶元素最小，对应最小优先队列；
    大顶堆是每一个根节点大于左右子节点的完全二叉树，堆顶元素最大，对应最大优先队列；
'''


class Solution(object):
    def maxEvents(self, events):
        """
        :type events: List[List[int]]
        :rtype: int
        """
        '''
        将 events 按照最小优先队列（小顶堆）的结构来储存，当队列不为空时，弹出队首元素，
            1. 判断能否参加会议，若结束时间小于当天，说明过期了不能参加，跳过；
            2. 如果可以参加，比较当天和开始时间：
                如果当天大于开始时间，说明我们没有必要非在今天参加，把 [当天，结束时间]重新加入优先队列，以查找有没有只能在今天参加的会议；
                如果当天等于开始时间，我们立即开始这个会议。因为优先队列保证开始时间相同时结束时间是递增的。
        '''
        import heapq
        res = 0
        heapq.heapify(events)  # 把events转化成堆结构
        cur = events[0][0]
        while events:
            s, e = heapq.heappop(events)
            # 如果结束时间小于当前天，说明过期了，不能参加
            if e < cur:
                continue
            # 如果开始时间小于当天，我们也不必今天参加，可以在（当天，结束天）任何一天参加
            if s < cur:
                heapq.heappush(events, [cur, e])
            else:
                cur = max(cur + 1, s + 1)
                res += 1
        return res


if __name__ == "__main__":
    events = [[1, 4], [4, 4], [2, 2], [3, 4], [1, 1]]
    print(Solution().maxEvents(events))
